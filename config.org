* Introductory Notes
This is my Emacs configuration. Most of it is stored as Emacs Lisp
source blocks in in this Org-mode file.

This file is called "config.org" and not "init.org" because during the
loading process, it creates a correspondingly-named ".el" file, and
there already is an "init.el" here. Note also that "README.org" is a
link here.

** How to install this config
In order to install this config, simply clone this repository into
=~/.emacs.d/=:

#+BEGIN_SRC sh
  git clone https://github.com/DarwinAwardWinner/dotemacs.git ~/.emacs.d
#+END_SRC

If you have an old =.emacs= file or =.emacs.d= directory that you want
to save, move them out of the way first so that they don't interfere
with the new config.

** First run
The first time you start up Emacs after installing this configuration, it
will install Cask, Pallet, then use those to install all necessary
packages, as described below in the Bootstrappping section. This will
take a while. Subsequent startups will not require this time and
should be relatively fast.

* Bootstrappping
The =init.el= file does all the bootstrapping necessary to load this
file. The following describes what happens in the init.el file.
** Disable GC during init
This sets the GC threshold extremely high so that garbage collection
will almost never occur during the initialization process. This
significantly speeds up the process. Obviously this provides the
greatest benefit if it is done as soon as possible during the init
process.
** Bootstrapping Cask & Pallet
This code ensures that Cask and Pallet are installed and properly set
up, and that all packages specified in the =Cask= file are installed and
initialized. One of those packages is org, which is naturally required
to load this file.

See the =Cask= file for the list of packages that will be
installed. This is modified by Pallet whenever ~package-install~ is
used to install a new package, and should not be edited manually.

** Load =config.org=
Finally, init.el loads this file using ~org-babel-load-file~. Because
it specifies the compile option, this may create a compile log
window. So the whole thing is wrapper in ~save-window-excursion~ to
ensure that the window configuration remains unchanged (but the
compile log buffer is left intact so any warnings or errros can still
be investigated).

* Fixing Default Directory
  Regardless of which directory Emacs is started from, I want the
  initial non-file buffers such as =*scratch*= and =*Messages*= to
  have their ~default-directory~ set to my home directory. This code
  goes through all non-file buffers whose default directories are the
  emacs starting directory or the root directory, and changes their
  default directories to my home directory.

  #+BEGIN_SRC emacs-lisp
    (let ((orig-default-directory default-directory))
      (unless (f-same? default-directory "~")
        (dolist (buf (buffer-list))
          (ignore-errors
            (with-current-buffer buf
              (when (and (null (buffer-file-name buf))
                         (or (f-same? default-directory orig-default-directory)
                             (f-root? default-directory)))
                (message "Changing default dir from %s to ~/ in %s"
                         default-directory (buffer-name buf))
                (cd "~")))))))
  #+END_SRC

* Package Configuration
  This section sets up some package-specific configuration options
  #+BEGIN_SRC emacs-lisp
    (require 'use-package)
  #+END_SRC

  Eval the following Elisp code to re-sort the below entries (this
  code line is not in a source block because it is not part of the
  actual configuration and should not be executed upon init):

  =CODE (org-sort-entries nil ?a) CODE=

** adjust-parens

   #+BEGIN_SRC emacs-lisp
     (use-package adjust-parens
       :commands adjust-parens-mode
       :init (progn
               ;; This line is required to silence a compiler warning
               (declare-function adjust-parens-mode (locate-library "adjust-parens"))
               (defun turn-on-adjust-parens-mode ()
                 (adjust-parens-mode 1))
               (dolist (hook '(lisp-interaction-mode-hook
                               emacs-lisp-mode-hook))
                 (add-hook hook #'turn-on-adjust-parens-mode)))
       :ensure t)
   #+END_SRC

** apache-mode

   #+BEGIN_SRC emacs-lisp
     (use-package apache-mode
       :mode ("/apache2/.*\\.conf\\'" . apache2-mode)
       :init (progn
               (defun apache-magic-mode-detect ()
                 (string-match-p "^\\s-*#.*\\bsyntax=apache\\b" (buffer-string)))
               (add-to-list 'magic-mode-alist '(apache-magic-mode-detect . apache-mode)))
       :ensure t)
   #+END_SRC

** auto-complete

   #+BEGIN_SRC emacs-lisp
     (use-package auto-complete
       :init (global-auto-complete-mode 1)
       :ensure t)
   #+END_SRC

** autopair

   #+BEGIN_SRC emacs-lisp
     (use-package autopair
       :init (progn (autopair-global-mode 1)
                    (setq autopair-skip-whitespace 'chomp)
                    (setq autopair-skip-criteria 'always))
       :ensure t)
   #+END_SRC

** bar-cursor

   #+BEGIN_SRC emacs-lisp
     (use-package bar-cursor
       :init (bar-cursor-mode 1)
       :ensure t)
   #+END_SRC

** browse-url

   #+BEGIN_SRC emacs-lisp
     (use-package browse-url
       :bind ("<s-mouse-1>" . browse-url-at-mouse)
       :ensure t)
   #+END_SRC

** bs (Buffer Show)

   #+BEGIN_SRC emacs-lisp
     (use-package bs
       :bind ("C-x C-b" . bs-show)
       :ensure t)
   #+END_SRC

** cl-lib

   #+BEGIN_SRC emacs-lisp
     (use-package cl-lib)
   #+END_SRC

** cperl-mode

   #+BEGIN_SRC emacs-lisp
     (use-package cperl-mode
       :init 
       ;; Replace `perl-mode' with `cperl-mode'.
       (progn
         (mapc 
          (lambda (x) 
            (when (eq (cdr x) 'perl-mode)
              (setcdr x 'cperl-mode)))
          auto-mode-alist)
         (mapc 
          (lambda (x) 
            (when (eq (cdr x) 'perl-mode)
              (setcdr x 'cperl-mode)))
          interpreter-mode-alist))
       :ensure t)
   #+END_SRC

** ess

   #+BEGIN_SRC emacs-lisp
     (use-package ess
       :config
       (progn
         (setq ess-default-style 'OWN)
         (setq ess-own-style-list
               (cons (cons 'ess-arg-function-offset-new-line '(4))
                     (cl-remove-if
                      (lambda (x)
                        (eq (car x) 'ess-arg-function-offset-new-line))
                      (cdr (assoc 'C++ ess-style-alist))))))
       :ensure t)
   #+END_SRC

** ess-site

   #+BEGIN_SRC emacs-lisp
     (use-package ess-site)
   #+END_SRC

** esup

   #+BEGIN_SRC emacs-lisp
     (use-package esup 
       :defer t
       :ensure t)
   #+END_SRC

** highlight-cl

   #+BEGIN_SRC emacs-lisp
     (use-package highlight-cl
       :init (progn
               (add-hook 'emacs-lisp-mode-hook 'highlight-cl-add-font-lock-keywords)
               (add-hook 'lisp-interaction-mode-hook 'highlight-cl-add-font-lock-keywords))
       :ensure t)
   #+END_SRC

** ido-speed-hack

   #+BEGIN_SRC emacs-lisp
     (use-package ido-speed-hack)
   #+END_SRC

** ido-ubiquitous

   #+BEGIN_SRC emacs-lisp
     (use-package ido-ubiquitous
       :ensure t)    
   #+END_SRC

** lexbind-mode

   #+BEGIN_SRC emacs-lisp
     (use-package lexbind-mode
       :init (add-hook 'emacs-lisp-mode-hook 'lexbind-mode)
       :ensure t)
   #+END_SRC

** magit

   #+BEGIN_SRC emacs-lisp
     (use-package magit
       :bind (("C-c g" . magit-status))
       :config (progn
                 (defun disable-magit-highlight-in-buffer () 
                   (face-remap-add-relative 'magit-item-highlight '()))
                 (add-hook 'magit-status-mode-hook 'disable-magit-highlight-in-buffer))
       :ensure t)
   #+END_SRC

** markdown-mode

   #+BEGIN_SRC emacs-lisp
     (use-package markdown-mode
       :mode ("\\.\\(md\\|mkdn\\)$" . markdown-mode)
       :ensure t)
   #+END_SRC

** org-mode
   The default implementation of the ~org-in-src-block-p~ function is
   broken and always returns nil, so we reimplement it correctly here.

   #+BEGIN_SRC emacs-lisp
     (use-package org
       :config
       (defun org-in-src-block-p (&optional inside)
         "Whether point is in a code source block.
          When INSIDE is non-nil, don't consider we are within a src block
          when point is at #+BEGIN_SRC or #+END_SRC."
         (save-match-data
           (let* ((elem (org-element-at-point))
                  (elem-type (car elem))
                  (props (cadr elem))
                  (end (plist-get props :end))
                  (pb (plist-get props :post-blank))
                  (content-end
                   (save-excursion
                     (goto-char end)
                     (forward-line (- pb))
                     (point)))
                  (case-fold-search t))
             (and
              ;; Elem is a src block
              (eq elem-type 'src-block)
              ;; Make sure point is not on one of the blank lines after the
              ;; element.
              (< (point) content-end)
              ;; If INSIDE is non-nil, then must not be at block delimiter
              (not
               (and
                inside
                (save-excursion
                  (beginning-of-line)
                  (looking-at ".*#\\+\\(begin\\|end\\)_src"))))))))
       ;; We don't set ensure here because the org-mode package has a
       ;; different name. See the Cask file.
       :ensure nil)
   #+END_SRC

** osx-pseudo-daemon

   #+BEGIN_SRC emacs-lisp
     (use-package osx-pseudo-daemon
       :ensure t)
   #+END_SRC

** pretty-symbols

   #+BEGIN_SRC emacs-lisp
     (use-package pretty-symbols
       :config
       (add-hook 
        'after-change-major-mode-hook
        (lambda ()
          (when (memq major-mode
                      (delete-dups
                       (cl-mapcan (lambda (x) (cl-copy-list (nth 3 x))) 
                               pretty-symbol-patterns)))
            (pretty-symbols-mode 1))))
       :ensure t)
   #+END_SRC

** smex

   #+BEGIN_SRC emacs-lisp
     (use-package smex
       :bind (("M-x" . smex)
              ("M-X" . smex-major-mode-commands)
              ("C-c C-c M-x" . execute-extended-command))
       :ensure t)
   #+END_SRC

* Set up and load a separate custom file 
This is the file where everything set via =M-x customize= goes.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (load custom-file)
#+END_SRC
* Tweaks
** Use GNU ls for ~insert-directory~ if possible
On OS X (and probably other platforms), "ls" may not refer to GNU
ls. If GNU ls is installed on these platforms, it is typically
installed under the name "gls" instead. So if "gls" is available, we
prefer to use it.

  #+BEGIN_SRC emacs-lisp
    (if (executable-find "gls")
        (setq insert-directory-program "gls"))
  #+END_SRC
** Use system trash bin
   TODO This is OSX-specific. Make it portable and more robust.

   #+BEGIN_SRC emacs-lisp
     (defvar trash-command "trash")
     
     (defun system-move-file-to-trash (filename)
       "Move file to OS X trash.
     
     This assumes that a program called `trash' is in your $PATH and
     that this program will, when passed a single file path as an
     argument, move that file to the trash."
       (call-process trash-command nil nil nil filename))
   #+END_SRC

** Use external mailer for bug reports
   This calls ~report-emacs-bug~, then ~report-emacs-insert-to-mailer~,
   then cleans up the bug buffers.

   The backquoting interpolation is used to copy the interactive form
   from ~report-emacs-bug~.

   #+BEGIN_SRC emacs-lisp
     (eval
      `(defun report-emacs-bug-via-mailer (&rest args)
         "Report a bug in GNU Emacs.
     
     Prompts for bug subject. Opens external mailer."
         ,(interactive-form 'report-emacs-bug)
         (save-window-excursion
           (apply 'report-emacs-bug args)
           (report-emacs-bug-insert-to-mailer)
           (mapc (lambda (buf) 
                   (with-current-buffer buf
                     (let ((buffer-file-name nil))
                       (kill-buffer (current-buffer)))))
                 (list "*Bug Help*" (current-buffer))))))
   #+END_SRC

** Pull PATH and MANPATH from shell

   #+BEGIN_SRC emacs-lisp
     ;; TODO: make a package out of this
     ;; Pull PATH and MANPATH from the shell
     (defun parse-envvar (var-and-value)
       (let ((match-pos (string-match-p "=" var-and-value)))
         (when match-pos
           (cons (substring var-and-value 0 match-pos)
                 (substring var-and-value (1+ match-pos))))))
     
     (defun pull-env-vars-from-shell (vars)
       (when (stringp vars)
         (setq vars (list vars)))
       (let* ((output (shell-command-to-string "bash --login -c env"))
              (lines (split-string output nil t)))
         (loop for line in lines
               for (var . value) = (parse-envvar line)
               if (member var vars)
               do (setenv var value)
               and if (string= var "PATH") do
               (setq exec-path (split-string value path-separator t)))))
     
     (pull-env-vars-from-shell '("PATH" "MANPATH"))
   #+END_SRC

** Fix OSX movement keys

   #+BEGIN_SRC emacs-lisp
     ;; Match standard OSX movement keys, etc. (compensating for swapping
     ;; alt and command keys)
     (when (or (featurep 'ns) 
               (eq system-type 'darwin))
       (when (version<= "24.4.0" emacs-version)
         (warn "Update the point movement key config in init.el"))
       ;; Super is the Alt/option key
       (global-set-key (kbd "s-<left>") 'left-word)
       (global-set-key (kbd "s-<right>") 'right-word)
       (global-set-key (kbd "s-<backspace>") 'backward-kill-word)
       (global-set-key (kbd "s-<kp-delete>") 'kill-word)
       (global-set-key (kbd "s-`") 'tmm-menubar)
       ;; Meta is the command key
       (global-set-key (kbd "M-<left>") 'move-beginning-of-line)
       (global-set-key (kbd "M-<right>") 'move-end-of-line)
       (global-set-key (kbd "M-<backspace>") nil)
       (global-set-key (kbd "M-<kp-delete>") nil)
       (global-set-key (kbd "M-`") 'other-frame))
   #+END_SRC

** Tell Emacs where to find its C source code

   #+BEGIN_SRC emacs-lisp
     (setq find-function-C-source-directory "~/src/emacs/src")
   #+END_SRC

** Allow typing a sexp and then replacing it with its value

   #+BEGIN_SRC emacs-lisp
     (defun eval-replace-preceding-sexp ()
       "Replace the preceding sexp with its value."
       (interactive)
       (let ((value (eval (preceding-sexp))))
         (kill-sexp -1)
         (insert (format "%s" value))))
     (global-set-key (kbd "C-c C-e") 'eval-replace-preceding-sexp)
   #+END_SRC

** Tell ~fixup-whitespace~ not to delete indentation

   #+BEGIN_SRC emacs-lisp
     (defadvice fixup-whitespace (around indent-line activate)
       "Don't delete indentation; instead do correct indentation.
     
     When `fixup-whitespace' is called with the point in the
     indentation region of the line (i.e. before the first
     non-whitespace character), indent the line instead of deleting
     the indentation."
       (if (<= (current-column)
              (save-excursion
                (back-to-indentation)
                (current-column)))
           (indent-for-tab-command)
         ad-do-it))
   #+END_SRC

** Have ~indent-region~ indent containing defun if mark is inactive

   #+BEGIN_SRC emacs-lisp
     (defadvice indent-region (around indent-defun activate)
       "Indent containing defun if mark is not active."
       (if (and transient-mark-mode
                (not mark-active))
           (save-excursion
             (mark-defun)
             (call-interactively #'indent-region))
         ad-do-it))
   #+END_SRC

** Always indent after newline

   #+BEGIN_SRC emacs-lisp
     (global-set-key (kbd "RET") #'newline-and-indent)
   #+END_SRC

** Turn on eldoc mode in elisp modes

   #+BEGIN_SRC emacs-lisp
     (dolist (hook '(lisp-interaction-mode-hook
                     emacs-lisp-mode-hook))
        (add-hook hook #'turn-on-eldoc-mode))
   #+END_SRC

** Fix ess-roxy behavior

   #+BEGIN_SRC emacs-lisp
     (eval-after-load 'ess-roxy
       '(defadvice newline-and-indent (around ess-roxy-newline activate)
          "Insert a newline in a roxygen field."
          (cond
           ;; Not in roxy entry; do nothing
           ((not (ess-roxy-entry-p))
            ad-do-it)
           ;; Point at beginning of first line of entry; do nothing
           ((= (point) (ess-roxy-beg-of-entry))
            ad-do-it)
           ;; Otherwise: skip over roxy comment string if necessary and then
           ;; newline and then inset new roxy comment string
           (t
            (let ((point-after-roxy-string
                   (save-excursion (forward-line 0)
                                   (move-beginning-of-line nil)
                                   (point))))
              (goto-char (max (point) point-after-roxy-string)))
            ad-do-it
            (insert (concat (ess-roxy-guess-str t) " "))))))
   #+END_SRC

** Tramp remote sudo

   #+BEGIN_SRC emacs-lisp
     (require 'tramp)
     (add-to-list 'tramp-default-proxies-alist
                  '(nil "\\`root\\'" "/ssh:%h:"))
     (add-to-list 'tramp-default-proxies-alist
                  '((regexp-quote (system-name)) nil nil))
   #+END_SRC

** Function for inserting src blocks in Org Mode

   #+BEGIN_SRC emacs-lisp
     (defun org-insert-src-block (src-code-type)
       "Insert a `SRC-CODE-TYPE' type source code block in org-mode."
       (interactive
        (let ((src-code-types
               '("emacs-lisp" "python" "C" "sh" "java" "js" "clojure" "C++" "css"
                 "calc" "asymptote" "dot" "gnuplot" "ledger" "lilypond" "mscgen"
                 "octave" "oz" "plantuml" "R" "sass" "screen" "sql" "awk" "ditaa"
                 "haskell" "latex" "lisp" "matlab" "ocaml" "org" "perl" "ruby"
                 "scheme" "sqlite")))
          (list (ido-completing-read "Source code type: " src-code-types))))
       (progn
         (newline-and-indent)
         (insert (format "#+BEGIN_SRC %s\n" src-code-type))
         (newline-and-indent)
         (insert "#+END_SRC\n")
         (forward-line -2)
         (org-edit-src-code)))
   #+END_SRC

** Use conf-mode for .gitignore files

   #+BEGIN_SRC emacs-lisp
     (add-to-list 'auto-mode-alist '("\\.gitignore\\'" . conf-mode))
   #+END_SRC

** Macros for running a function without user input
This code builds up the ~without-user-input~ function, which is like
~progn~ except that if BODY makes any attempt to read user input, all
further execution is calceled and the form returns nil (note that it
does /not/ signal an error, it simply returns).

   #+BEGIN_SRC emacs-lisp
     (require 'cl-macs)

     (defmacro without-minibuffer (&rest body)
       "Like `progn', but stop and return nil if BODY tries to use the minibuffer.

     Also disable dialogs while evaluating BODY forms, since dialogs
     are just an alternative to the minibuffer."
       `(catch 'tried-to-use-minibuffer
          (minibuffer-with-setup-hook
              (lambda (&rest args) (throw 'tried-to-use-minibuffer nil))
            (let ((use-dialog-box))          ; No cheating by using dialogs instead of minibuffer
              ,@body))))

     (defmacro without-functions (flist &rest body)
       "Evaluate BODY, but stop and return nil if BODY calls any of the functions named in FLIST."
       (let* (;; Functions are disabled by setting their body to this
              ;; temporarily.
              (fbody
               '((&rest args) (throw 'forbidden-function nil)))
              ;; This will form the first argument to `flet'
              (function-redefinitions
               (mapcar (lambda (fname) (cons fname fbody)) flist)))
         `(catch 'forbidden-function
            (cl-flet ,function-redefinitions
              ,@body))))

     (defmacro without-user-input (&rest body)
       "Like `progn', but prevent any user interaction in BODY."
       `(without-functions (read-event)
          (without-minibuffer
            ,@body)))

     ;; These should be indented like progn
     (put 'without-minibuffer 'lisp-indent-function
          (get 'progn 'lisp-indent-function))
     (put 'without-functions 'lisp-indent-function
          (get 'let 'lisp-indent-function))
     (put 'without-user-input 'lisp-indent-function
          (get 'progn 'lisp-indent-function))
   #+END_SRC

** Emacs desktop additions
The following additions ensure that the saved desktop file is always
up-to-date.

*** Add a desktop-save function that aborts if user input is required
When running in hooks, it's not disasterous if we can't save the
desktop for some reason, and we don't want to bother the user, so we
wrap the normal saving function to force it to do nothing instead of
asking for user input.

    #+BEGIN_SRC emacs-lisp
      (defun desktop-save-in-desktop-dir-never-ask (&rest args)
        "Like `desktop-save-in-desktop-dir' but aborts if input is required.

      If `desktop-save-in-desktop-dir' tries to solicit user input,
      this aborts and returns nil instead. It is intended for use in
      place of `desktop-save-in-desktop-dir' in hooks where you don't
      want to bother the user if something weird happens."
        (without-user-input
          (apply #'desktop-save-in-desktop-dir args)))
    #+END_SRC

*** Save desktop with every autosave

    #+BEGIN_SRC emacs-lisp
      (add-hook 'auto-save-hook 'desktop-save-in-desktop-dir-never-ask)
    #+END_SRC

*** Save desktop after opening or closing a file
This will ensure that all open files are saved in the desktop. An idle
timer and tripwire variable are used used to avoid saving the desktop
multiple times when multiple files are opened or closed in rapid
succession.

    #+BEGIN_SRC emacs-lisp
      (defvar desktop-mode-desktop-is-stale nil
        "This is set to non-nil when a file is opened or closed.")

      (defun desktop-mode-set-stale ()
        "If current buffer has a file, set the stale desktop flag."
        (when buffer-file-name
          (setq desktop-mode-desktop-is-stale t)))
      (defun desktop-mode-set-current ()
        "Unconditionally clear the stale desktop flag."
        (setq desktop-mode-desktop-is-stale nil))
      (add-hook 'kill-buffer-hook #'desktop-mode-set-stale)
      (add-hook 'find-file-hook #'desktop-mode-set-stale)
      (add-hook 'desktop-after-read-hook #'desktop-mode-set-current)

      (defun desktop-mode-save-if-stale ()
        (when desktop-mode-desktop-is-stale
          (desktop-save-in-desktop-dir-never-ask)
          (desktop-mode-set-current)))

      (run-with-idle-timer 0.1 t #'desktop-mode-save-if-stale)
    #+END_SRC

** Set up a function for reloading the init file

   #+BEGIN_SRC emacs-lisp
     (defun reinit ()
       (interactive)
       (save-window-excursion
         (load user-init-file)))
   #+END_SRC

* Start emacs server
This allows ~emacsclient~ to connect.

  #+BEGIN_SRC emacs-lisp
    (ignore-errors (server-start))
  #+END_SRC

